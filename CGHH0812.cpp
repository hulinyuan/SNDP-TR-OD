//头文件using namespace std;#include"D:\A_smartWorderrack\MPORJSP\Program C++\self_Define_headFile\Use_Curobi_Win64_C++.h"// gurobi调用配置#include"D:\A THESIS-SNDZROC\C++ Programming\CGHH0812\tools.h"// 辅助性质小函数#include"D:\A THESIS-SNDZROC\C++ Programming\CGHH0812\Instance.h"//获取算例数值，得到时空网络#include"D:\A THESIS-SNDZROC\C++ Programming\CGHH0812\MNFP.h"  //求解网络流模型，得到初始解#include"MNFP.h"#include"D:\A THESIS-SNDZROC\C++ Programming\CGHH0812\LPSNDAC.h"#include"D:\A THESIS-SNDZROC\C++ Programming\CGHH0812\MIPSNDAC.h"#include"D:\A THESIS-SNDZROC\C++ Programming\CGHH0812\SSAP.h"#include"D:\A THESIS-SNDZROC\C++ Programming\CGHH0812\SNDAA.h"int main(){	double SIGMA = 0.1;	CYCLEMAP CM;	vector<vector<vector<vector<vector<double>>>>> stmrho;	int tdiver = 0; //多样化策略执行次数	int tdiMAX = 3;//多样化策略执行次数上限	int iter = 0; //每个领域内迭代次数	int TMAX = 10;//每个领域内迭代次数上限	//读取算例	INSTANCE instance;	string filename = "D:/A THESIS-SNDZROC/C++ Programming/CGHH0812/instance/ins1.csv";	instance = getInstance(filename);	//时空网络	TSNET tsnet = GenTimeSpacenet(instance.Breakbulks, instance.Physicalnet, instance.T);	// 区域连接矩阵，记录每个区域连接的站点	vector<vector<vector<int>>> zone_con = GenZonem(instance.con, tsnet.zone);	/*===============================================================MIP—AA 求解======================================================================	PAR_LPAC sol_mipaa;	sol_mipaa.T = instance.T;	sol_mipaa.tsnet = tsnet;	sol_mipaa.rd = instance.RD;	sol_mipaa.sd = instance.SD;	sol_mipaa.zone_con = zone_con;	sol_mipaa.Vehicles = instance.Vehicles;	SolveMIPAA(sol_mipaa);  */  /*===============================================================DSSP求解======================================================================*/  //求解MNFPOD	PAR_MNFP par_mnfp;	par_mnfp.RD = instance.RD;	par_mnfp.SD = instance.SD;	par_mnfp.ts_net = tsnet;	TSNET mnfp_tsnet;	mnfp_tsnet = SolveMNFP(par_mnfp);	PAR_LPAC par_lpac;	par_lpac.T = instance.T;	par_lpac.tsnet = tsnet;	par_lpac.rd = instance.RD;	par_lpac.sd = instance.SD;	par_lpac.zone_con = zone_con;	par_lpac.Vehicles = instance.Vehicles;	//初始服务圈生成	par_lpac.Phi = Getinitialcycle(mnfp_tsnet, zone_con, instance.Vehicles, instance.T);	//初始服务圈记录	CYCLEMAP CM;	for (int z = 0; z < instance.Vehicles.size(); z++) {		for (int v = 0; v < instance.Vehicles[z].size(); v++) {			for (int i = 0; i < par_lpac.Phi[z][v].size(); i++) {				int num = CM.addcycle(z, v, par_lpac.Phi[z][v][i]);				CM.cycles[num].num = num;			}		}	}	SOL_LPAC sol_lpac = SolveLPAC(par_lpac); // 列生成迭代	while (sol_lpac.lpac_status > 0) { // 判断是否需要继续求解 lpac 状态值为1时需要继续迭代		par_lpac.T = instance.T;		par_lpac.tsnet = tsnet;		par_lpac.Phi = sol_lpac.phi_all;		par_lpac.rd = instance.RD;		par_lpac.sd = instance.SD;		par_lpac.zone_con = zone_con;		par_lpac.Vehicles = instance.Vehicles;		sol_lpac = SolveLPAC(par_lpac);	}	vector<vector<vector<int>>> zphi; // 得到列生成结束时最优解中使用的服务圈	for (int z = 0; z < instance.Vehicles.size(); z++) {		vector<vector<int>> phis;		for (int v = 0; v < instance.Vehicles[z].size(); v++) {			for (int i = 0; i < sol_lpac.phi_all[z][v].size(); i++) {				if (sol_lpac.vhc_status[z][v][i] > 0) {					phis.push_back(sol_lpac.phi_all[z][v][i]);				}			}		}		zphi.push_back(phis);	}	PAR_SSAP par_ssap;                                  //定义求解AP模型的参数	par_ssap.RD = instance.RD;                          //添加常规需求	for (int g = 0; g < sol_lpac.mg_status.size(); g++) {		if (sol_lpac.mg_status[g] == 1) {			par_ssap.RD.push_back(instance.SD[g]);		}	}	par_ssap.V = instance.Vehicles;                     // 添加货车	par_ssap.tsnet = tsnet;                             // 添加时空网络	for (int z = 0; z < instance.Vehicles.size(); z++) {		//添加列生成最后解中使用的服务圈，重复地分配给每个货车    		vector<vector<vector<int>>> vphi;		vector<vector<CYCLE>> zvc;		for (int v = 0; v < instance.Vehicles[z].size(); v++) {			vector<vector<int>> phis;			vector<CYCLE>  vc;			for (int i = 0; i < zphi[z].size(); i++) {				phis.push_back(zphi[z][i]);				CYCLE cycle;				cycle.fre = 1;				cycle.phi = zphi[z][i];				cycle.v = v;				cycle.z = z;				vc.push_back(cycle);			}			vphi.push_back(phis);			zvc.push_back(vc);		}		par_ssap.phi.push_back(vphi);	}	vector<vector<vector<double>>>  recordrho;//记录所用的服务圈出现在ssap解中的次数	for (int z = 0; z < par_ssap.phi.size(); z++) {		vector<vector<double>> vrho;		for (int v = 0; v < par_ssap.phi[z].size(); v++) {			vector<double> rho;			for (int i = 0; i < par_ssap.phi[z][v].size(); i++) {				rho.push_back(0);			}			vrho.push_back(rho);// 记录第一批服务圈对应的次数的变量初始化		}		recordrho.push_back(vrho);	}	par_ssap.rho_k = InitialRho(par_ssap.RD, par_ssap.V, par_ssap.phi, tsnet.as); //乘子初始化	SOL_SSAP sol_ssap = SolveAPac(par_ssap);                                     // 第一次求解AP	FSOL fsol_in = genFeaisblesol(par_ssap, instance.T, zone_con, par_lpac, sol_ssap); // 精确求解受限MIP问题得到可行解			// 记录可行解，可行解中使用的服务圈	double lastobj = 0; //当前解的上一个解还没有，记为0	double curobj = sol_ssap.obj; //将初始的第一个ssap解记为当前解	bool Dstartflag = 0;	bool Endflag = 0;	int coutd = 0;	while (Endflag != 1) {		while (lastobj != curobj) {// 前后解不同时在相同的服务圈集合下执行乘子更新迭代			lastobj = curobj;// 将当前解降级为上一个解			par_ssap.rho_k = Updaterho(par_ssap.RD, par_ssap.V,par_ssap.phi, sol_ssap.xkzvis, tsnet.as, par_ssap.rho_k, recordrho); //更新乘子			sol_ssap = SolveAPac(par_ssap);         // 在相同的服务圈集合下用更新后的乘子求解SSAP			curobj = sol_ssap.obj; // 记录当前求解得到的SSAP的解			fsol_in = genFeaisblesol(par_ssap, instance.T, zone_con, par_lpac, sol_ssap); // 精确求解受限MIP问题得到可行解				  // 记录可行解		}		if (lastobj == curobj) {			Dstartflag = 1;// 如果当前解与上一个解相同，那么将多样化策略的开关打开			coutd = 0;		}		while (Dstartflag != 0) { //如果非关，则对乘子增加惩罚项			lastobj = curobj;			par_ssap.rho_k = Punishrho(lastobj, par_ssap.RD, par_ssap.V,				par_ssap.phi, sol_ssap.xkzvis, tsnet.as, par_ssap.rho_k); //更新乘子			sol_ssap = SolveAPac(par_ssap);         // 求解AP			curobj = sol_ssap.obj;			fsol_in = genFeaisblesol(par_ssap, instance.T, zone_con, par_lpac, sol_ssap);			coutd++;			if (coutd == 3) {				Dstartflag = 0;			}		}		// 基于当前的服务圈给出新的服务圈领域更新par_ssap.phi, rho: genneighbor(par_ssap.phi)	}   return 0;   }